\documentclass[UTF8,a4paper,12pt]{ctexbook} 

\usepackage{graphicx}%学习插入图
\usepackage{verbatim}%学习注释多行
\usepackage{booktabs}%表格
\usepackage{longtable} 
\usepackage{geometry}%图片
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}%代码
\usepackage{xcolor}  %颜色
\usepackage{enumitem}%列表格式
\setenumerate[1]{itemsep=0pt,partopsep=0pt,parsep=\parskip,topsep=5pt}
\setitemize[1]{itemsep=0pt,partopsep=0pt,parsep=\parskip,topsep=5pt}
\setdescription{itemsep=0pt,partopsep=0pt,parsep=\parskip,topsep=5pt}

\usepackage{tcolorbox}
\usepackage{algorithm}  %format of the algorithm
\usepackage{algorithmic}%format of the algorithm
\usepackage{multirow}   %multirow for format of table
\usepackage{tabularx} 	%表格排版格式控制
\usepackage{array}	%表格排版格式控制
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{dirtree}


\usetikzlibrary{intersections,
	positioning,
	petri,
	backgrounds,
	fit,
	decorations.pathmorphing,
	arrows,
	arrows.meta,
	bending,
	calc,
	intersections,
	through,
	backgrounds,
	shapes.geometric,
	quotes,
	matrix,
	trees,
	shapes.symbols,
	graphs,
	math,
	patterns,
	external}
\CTEXsetup[format+={\flushleft}]{section}

%%%% 设置图片目录
\graphicspath{{figure/}}
\CTEXsetup[format+={\flushleft}]{section}
%%%% 下面的命令添加新字体 %%%%%


%%%%%% 设置字号 %%%%%%
\newcommand{\chuhao}{\fontsize{42pt}{\baselineskip}\selectfont}
\newcommand{\xiaochuhao}{\fontsize{36pt}{\baselineskip}\selectfont}
\newcommand{\yihao}{\fontsize{28pt}{\baselineskip}\selectfont}
\newcommand{\erhao}{\fontsize{21pt}{\baselineskip}\selectfont}
\newcommand{\xiaoerhao}{\fontsize{18pt}{\baselineskip}\selectfont}
\newcommand{\sanhao}{\fontsize{15.75pt}{\baselineskip}\selectfont}
\newcommand{\sihao}{\fontsize{14pt}{\baselineskip}\selectfont}
\newcommand{\xiaosihao}{\fontsize{12pt}{\baselineskip}\selectfont}
\newcommand{\wuhao}{\fontsize{10.5pt}{\baselineskip}\selectfont}
\newcommand{\xiaowuhao}{\fontsize{9pt}{\baselineskip}\selectfont}
\newcommand{\liuhao}{\fontsize{7.875pt}{\baselineskip}\selectfont}
\newcommand{\qihao}{\fontsize{5.25pt}{\baselineskip}\selectfont}

%%%% 段落首行缩进两个字 %%%%
\makeatletter
\let\@afterindentfalse\@afterindenttrue
\@afterindenttrue
\makeatother
\setlength{\parindent}{2em}  %中文缩进两个汉字位


%%%% 下面的命令重定义页面边距，使其符合中文刊物习惯 %%%%
\addtolength{\topmargin}{-54pt}
\setlength{\oddsidemargin}{0.63cm}  % 3.17cm - 1 inch
\setlength{\evensidemargin}{\oddsidemargin}
\setlength{\textwidth}{14.66cm}
\setlength{\textheight}{24.00cm}    % 24.62

%%%% 下面的命令设置行间距与段落间距 %%%%
\linespread{1.4}
\setlength{\parskip}{0.5\baselineskip}

%%%% 下面的命令定义图表、算法、公式 %%%%
\newcommand{\EQ}[1]{$\textbf{EQ:}#1\ $}
\newcommand{\ALGORITHM}[1]{$\textbf{Algorithm:}#1\ $}
\newcommand{\Figure}[1]{$\textbf{Figure }#1\ $}

%%%% 下面命令改变图表下标题的前缀 %%%%% 如:图-1、Fig-1
\renewcommand{\figurename}{Fig}

\geometry{left=1.6cm,right=1.8cm,top=2cm,bottom=1.7cm} %设置文章宽度

\pagestyle{plain} 		  %设置页面布局

%代码效果定义
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\lstset{ %
	backgroundcolor=\color{white},   % choose the background color
	basicstyle=\footnotesize\ttfamily,        % size of fonts used for the code
	columns=fullflexible,
	breaklines=true,                 % automatic line breaking only at whitespace
	captionpos=b,                    % sets the caption-position to bottom
	tabsize=4,
	commentstyle=\color{mygreen},    % comment style
	escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
	keywordstyle=\color{blue},       % keyword style
	stringstyle=\color{mymauve}\ttfamily,     % string literal style
	frame=single,					%tb top and bottom; L left double line
	xleftmargin=.06\textwidth, 
	%xrightmargin=.1\textwidth,
	rulesepcolor=\color{red!20!green!20!blue!20},
	% identifierstyle=\color{red},
	language=python,
}

\setcounter{tocdepth}{4}	
\author{\kaishu 郑华}
\title{Python 学习笔记}

\begin{document}          %正文排版开始
 	\maketitle
 	\tableofcontents

\chapter{基本}
	\section{参考}
		菜鸟教程：\url{http://www.runoob.com/python3/python3-basic-syntax.html}
	\section{关键字}
		\paragraph{常量}True  False None
		
		\paragraph{对象与容器} class import from del
		
		\paragraph{逻辑操作} and or not
		
		\paragraph{函数} def return 
		
		\paragraph{判断与循环':'} if elif else is in assert for while continue break
		
		\paragraph{异常} raise try except finally with as
		
		\paragraph{作用域} global nonlocal
		
		\paragraph{匿名函数与协程} yield lambda
		
	\section{容器与字符串}
		\subsection{list 数组}
			\paragraph{用法示例}\verb|->|
				\begin{lstlisting}
	# 定义
	li = [1,2,3,4,5]
	
	#遍历
	for i in li:
		print(i)	
		
	#使用range
	#range(x) -> [0, x-1]
	#range(x,y) -> [x, y-1]	
	#range(x,y,z) ->[x, y-1]间隔为z -> [x, x+z, x+2z, ..]	
	for i in range(len(li))
		print(i)
		
	#负数索引: 倒数第多少
	print(li[-1])
	
	li2 = []
	#添加元素
	li2.append(1)
	li2.append('123')
	li2.append(['d','ef','a'])	
	
	#合并两个数组
	li.extend(li2)

	#删除元素
	li2.pop()
	li2.pop(2) #删除索引位置
	
	#排序
	li2.sort()
	def item_key(x):
		return x[0]
	li2.sort(key = item_key) 	
	li2.sort(key = lambda x:x[0]) #与上述等价 
				\end{lstlisting}
			
			
		\subsection{tuple 只读数组}
			\begin{lstlisting}
	tp = (1,2,3)
			\end{lstlisting}
		
		\subsection{set 没用重复元素的数组}
			\begin{lstlisting}
	# 使用list 初始化
	st = set([1,2,3,4,2,3,5]) 
	# 自动去重并排序
	# 使用tuple 初始化
	st = set((2,2,3,4,5))
			\end{lstlisting}	

		\subsection{dict 字典map}
			\begin{lstlisting}
	# 空子典
	di = {}
	di = {'k1':'v1','k2':'v2'}
	di['k3'] = 'v3'
	
	for k in di:
		print(di[k])
	
	for k,v in di.items():
		print(k,v)
			\end{lstlisting}
		
		\subsection{数组切片}
			\begin{lstlisting}
	#[start, end, step] -> [start, start+step, ...<end]
	#start 默认等于0   #end 默认等于-1   #step 默认等于1
	li = [1,2,3,4,5]
	li_0_2 = li[0:3] #-> li[0] li[1] li[2] ->i>=start < end
	
	# 直接用切片反转数组,切片是复制操作
	print(li[::-1])
			\end{lstlisting}
			
		\subsection{字符串与数组的关系}
			默认的字符串相当于c++ 里面的字符串常量，需要利用list(str) 将其转化成字符数组进行操作。
			
			然后通过\verb|''.join(list)| 将list转化为string 
			
			\paragraph{切割}\verb|-|
				\begin{lstlisting}
	s = 'abc,def,ghi'
	p1,p2,p3 = s.split(',')
	print(p1,p2,p3)
				\end{lstlisting}
				
			\paragraph{切片}\verb|同list|
	\section{函数}
		\paragraph{定义函数}\verb|->|
			\begin{lstlisting}
	def func():
		pass
			\end{lstlisting}
			
		\paragraph{默认参数}
		
		\paragraph{名字参数}
		
		\paragraph{函数可以当成变量}
		
		\paragraph{函数式编程map/reduce}
		
	\section{面向对象}
		\paragraph{type(parameter)} 查看对象类型
		
		\paragraph{isinstance(a,object)} 查看a 是否是 object(\textit{或其他})类型。
		\subsection{定义}
			\paragraph{绑定属性}\verb|__init__|绑定属性,并且第一个参数是self 且不能忘记
			
				\begin{lstlisting}
	class Clazz(object):	
		def __init__(self, x, y)
			self.x = x
			self.y = y
				\end{lstlisting}
			
			\paragraph{实例化}\verb|clz = Clazz(100,200)|
			
		\subsection{this -> self}self 等价于this 指针
		
		\subsection{多态与继承}
			\begin{lstlisting}
	class Base:
		def run(self):
			print('Base:run')
			
	class Tom(Base):
		def run(self):
			print('Tom:run')
	
	t = Tom()
	t.run()
			\end{lstlisting}
		
	\section{文件读写}
		\subsection{文本文件读写}
			\begin{lstlisting}
	f = open('text.txt','r')
	# 打印整个文件
	print(f.read())
	# 按行打印
	for line in f.readlines():
		print(line)
		
	# 异常 处理
	with open('text.txt') as f:
		for line in f.readlines():
			print(line)
			\end{lstlisting}
		
	
		\subsection{二进制文件读写}
		
		\subsection{string 与 bytes}
		
		\subsection{文件和目录操作}
			
	\section{多线程}
		\subsection{多线程}线程与进程消耗的是一样的在Python 里
		
			\begin{lstlisting}
	# 引入线程包
	import threading
	 
	# 定义线程函数
	def thread_func(x):
		print('%d\n',%(x*100))
	
	# 添加线程	
	threads = []
	for i in range(5)
		threads.append( threading.Thread(target = thread_func, args = (100,)) )
	
	# 执行线程
	for thread in threads:
		thread.start()
	
	# 等待线程结束
	for thread in threads:
		thread.join()
	
			\end{lstlisting}
		\subsection{多进程}
		
		\subsection{线程同步}

		
	\section{错误与异常}
		\paragraph{基础使用}\verb_~_
			\begin{lstlisting}
	try:
		r = 10/0
	# 捕获具体类型的异常
	except ZeroDivisionError as e:
		print(type(e))
		print(e)
	finally:
		# 防止资源泄露
		print('always come here')
			\end{lstlisting}
		
		\paragraph{logging 库}\verb_~_
			\begin{lstlisting}
	import logging
	
	logging.info('xx')
	logging.debug('xx')
			\end{lstlisting}	
		

\chapter{爬虫}
	\section{基础}
		\paragraph{安装第3方包}\verb|pip install package|
		
		\subsection{HTTP 简介}
			\paragraph{概念}
				\begin{itemize}
					\item Http = hyperText Transfer Protocol
					\item URI = Uniform Resource Identifier
					\item URL = Uniform Resource Locator
					\item URI 和 URL的区别：URI强调的是资源，URL强调的是资源的位置。
				\end{itemize}
			
			\paragraph{请求类型}
				\begin{itemize}
					\item \verb|OPTIONS :|返回服务器针对特定资源所支持的http 请求方法
					\item \verb|HEAD :|向服务器索要与get 请求相一致的响应，只不过响应体将不会返回。只是确定文件是否存在。
					\item \verb|GET :|向特定资源发出请求
					\item \verb|PUT :|向指定资源位置上传其最新内容
					\item \verb|POST :|向指定资源提交数据进行处理请求
					\item \verb|DELETE :|请求服务器删除特定URI所标识的资源
					\item \verb|PATCH :|用于将局部修改应用于某一资源
				\end{itemize}
			
			\paragraph{常见状态码}
				\begin{itemize}
					\item \verb|200/OK :|请求成功
					\item \verb|201/Created:|请求已被实现，且一个新资源已根据请求被建立，URI跟随Location 头信息返回。
					\item \verb|202/Accepted:|服务器已接受请求，但尚未处理
					\item \verb|400/Bad Request:|请求无法被服务器理解
					\item \verb|401/Unauthorized:|当前请求需要用户验证
					\item \verb|403/Forbidden:|服务器已理解请求，但是拒绝执行
					\item \verb|404/Not Found:|未发现
				\end{itemize}
				
		\subsection{HTML/XML/Json 简介}
			Html:标签
			
			Xml:树结构
			
			Json(JavaScript Object Notation):类似与XML，但是更小、更快、解析更容易。
		
		\subsection{CSS 定位器}
				
			
		\subsection{MySQL/SqlLite}
		
		
		\subsection{爬虫框架}
			\begin{itemize}
				\item 将种子URL放入队列
				\item 从队列中获取URL，抓取内容
				\item 解析抓取内容，将需要进一步抓取的URL放入工作队列，存储解析后的内容
			\end{itemize}
			
			\paragraph{抓取策略}
				\begin{itemize}
					\item 深度优先
					\item 广度优先
					\item PageRank
					\item 大站优先
				\end{itemize}
			
			\paragraph{如何去重}
				\begin{itemize}
					\item Hash 表
					\item bloom 过滤器
				\end{itemize}	
		
	\section{相关库的使用}
	
	
	
	\section{Scrapy 及相关应用}
	
	
	\section{爬虫设计实战}
	
	
	
	\section{高级内容-并发编程}
	
	
	
	\section{分布式爬虫框架设计}
	
	
	
		

\end{document} 
 		    