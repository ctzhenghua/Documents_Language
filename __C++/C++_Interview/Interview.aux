\relax 
\providecommand\hyper@newdestlabel[2]{}
\providecommand\HyperFirstAtBeginDocument{\AtBeginDocument}
\HyperFirstAtBeginDocument{\ifx\hyper@anchor\@undefined
\global\let\oldcontentsline\contentsline
\gdef\contentsline#1#2#3#4{\oldcontentsline{#1}{#2}{#3}}
\global\let\oldnewlabel\newlabel
\gdef\newlabel#1#2{\newlabelxx{#1}#2}
\gdef\newlabelxx#1#2#3#4#5#6{\oldnewlabel{#1}{{#2}{#3}}}
\AtEndDocument{\ifx\hyper@anchor\@undefined
\let\contentsline\oldcontentsline
\let\newlabel\oldnewlabel
\fi}
\fi}
\global\let\hyper@last\relax 
\gdef\HyperFirstAtBeginDocument#1{#1}
\providecommand*\HyPL@Entry[1]{}
\HyPL@Entry{0<</S/D>>}
\@writefile{toc}{\contentsline {section}{\numberline {1}参考学习网址}{5}{section.1}}
\@writefile{toc}{\contentsline {section}{\numberline {2}Linux}{6}{section.2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.1}题目}{6}{subsection.2.1}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.1}熟练netstat tcpdump ipcs ipcrm}{6}{subsubsection.2.1.1}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.2}共享内存段被映射进进程空间之后，存在于进程空间的什么位置？共享内存段}{6}{subsubsection.2.1.2}}
\@writefile{toc}{\contentsline {subparagraph}{共享内存定义}{6}{section*.2}}
\@writefile{toc}{\contentsline {subparagraph}{共享内存的使用实现原理}{6}{section*.3}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.3}进程内存空间分布情况}{6}{subsubsection.2.1.3}}
\@writefile{toc}{\contentsline {subparagraph}{内核空间和用户空间}{6}{section*.4}}
\@writefile{toc}{\contentsline {subparagraph}{用户空间布局}{6}{section*.5}}
\@writefile{toc}{\contentsline {subparagraph}{多线程程序与普通程序的内存布局的不同}{7}{section*.6}}
\@writefile{toc}{\contentsline {subparagraph}{其他细节}{7}{section*.7}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.4}ELF是什么？其大小与程序中全局变量的是否初始化有什么关系}{7}{subsubsection.2.1.4}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.5}动态链接和静态链接的区别？}{7}{subsubsection.2.1.5}}
\@writefile{toc}{\contentsline {subparagraph}{静态库与动态库}{7}{section*.8}}
\@writefile{toc}{\contentsline {subparagraph}{静态库与导入库的区别}{8}{section*.9}}
\@writefile{toc}{\contentsline {subparagraph}{动态链接与静态链接}{8}{section*.10}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.6}32位系统一个进程最多有多少堆内存}{8}{subsubsection.2.1.6}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.7}写一个c程序辨别系统是大端or小端字节序}{8}{subsubsection.2.1.7}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.8}信号：列出常见的信号，信号怎么处理？}{8}{subsubsection.2.1.8}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.9}i++ 是否原子操作?并解释为什么?}{8}{subsubsection.2.1.9}}
\@writefile{toc}{\contentsline {subparagraph}{原子操作}{8}{section*.11}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.10}说出你所知道的各类linux系统的各类同步机制（重点），什么是死锁？如何避免死锁}{9}{subsubsection.2.1.10}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.11}如何实现守护进程？}{9}{subsubsection.2.1.11}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.12}linux的任务调度机制是什么？}{9}{subsubsection.2.1.12}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.13}标准库函数和系统调用的区别？}{9}{subsubsection.2.1.13}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.14}系统如何将一个信号通知到进程？}{9}{subsubsection.2.1.14}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.15}fork()一子进程程后父进程的全局变量能不能使用？}{9}{subsubsection.2.1.15}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.16}多线程与多进程的区别}{9}{subsubsection.2.1.16}}
\@writefile{toc}{\contentsline {subparagraph}{线程安全的条件}{9}{section*.12}}
\@writefile{toc}{\contentsline {subparagraph}{关于线程的堆栈}{9}{section*.13}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.17}多线程的各种锁！}{9}{subsubsection.2.1.17}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.18}缓存淘汰算法-LRU}{9}{subsubsection.2.1.18}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.19}可重入与不可重入}{10}{subsubsection.2.1.19}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.20}crontab原理}{10}{subsubsection.2.1.20}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.21}*coreDump}{10}{subsubsection.2.1.21}}
\@writefile{toc}{\contentsline {subparagraph}{概念}{10}{section*.14}}
\@writefile{toc}{\contentsline {subparagraph}{coreDump 文件}{10}{section*.15}}
\@writefile{toc}{\contentsline {subparagraph}{如何判断一个文件是coredump文件}{10}{section*.16}}
\@writefile{toc}{\contentsline {subparagraph}{coredump产生的几种可能情况}{10}{section*.17}}
\@writefile{toc}{\contentsline {subparagraph}{利用gdb进行coredump的定位}{11}{section*.18}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.22}线程达到线程池定义个数，怎么办}{11}{subsubsection.2.1.22}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.23}Linux 能同时启动多少个线程}{11}{subsubsection.2.1.23}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.24}多线程 能提高 并发度么？}{11}{subsubsection.2.1.24}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.2}惊群}{11}{subsection.2.2}}
\@writefile{toc}{\contentsline {subparagraph}{解决}{11}{section*.19}}
\@writefile{toc}{\contentsline {section}{\numberline {3}C++}{12}{section.3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.1}题目}{12}{subsection.3.1}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.1}文本文件和二进制文件的区别}{12}{subsubsection.3.1.1}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.2}结构体用memcmp比较的问题}{12}{subsubsection.3.1.2}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.3}memcpy 实现}{12}{subsubsection.3.1.3}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.4}strcpy 实现}{12}{subsubsection.3.1.4}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.5}strcat 实现}{12}{subsubsection.3.1.5}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.6}书写 给定类的赋值操作符 = }{12}{subsubsection.3.1.6}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.7}什么是“引用”？申明和使用“引用”要注意哪些问题？}{12}{subsubsection.3.1.7}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.8}将“引用”作为函数参数有哪些特点？}{13}{subsubsection.3.1.8}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.9}在什么时候需要使用“常引用”？}{13}{subsubsection.3.1.9}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.10}将“引用”作为函数返回值类型的格式、好处和需要遵守的规则?}{13}{subsubsection.3.1.10}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.11}引用与指针的区别是什么？}{13}{subsubsection.3.1.11}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.12}什么时候需要“引用”？}{13}{subsubsection.3.1.12}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.13}结构与联合有和区别？}{14}{subsubsection.3.1.13}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.14} 已知strcpy的函数原型：char *strcpy(char *strDest, const char *strSrc)其中strDest 是目的字符串，strSrc 是源字符串。不调用C++/C 的字符串库函数，请编写函数 strcpy}{14}{subsubsection.3.1.14}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.15}不用中间变量实现交换swap的问题}{14}{subsubsection.3.1.15}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.16}＃include<file.h> 与＃include "file.h"的区别？}{14}{subsubsection.3.1.16}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.17}面向对象的三个基本特征，并简单叙述之？}{14}{subsubsection.3.1.17}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.18}重载（overload)和重写(overried，有的书也叫做“覆盖”）的区别？}{14}{subsubsection.3.1.18}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.19}多态的作用？}{15}{subsubsection.3.1.19}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.20}virtual 指针与对象初始化的区别}{15}{subsubsection.3.1.20}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.21}New delete 与malloc free 的联系与区别?}{15}{subsubsection.3.1.21}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.22}有哪几种情况只能用intializationlist 而不能用assignment?}{15}{subsubsection.3.1.22}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.23}C++是不是类型安全的？}{15}{subsubsection.3.1.23}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.24}指针函数与函数指针}{15}{subsubsection.3.1.24}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.25}请说出const与\#define 相比，有何优点？}{16}{subsubsection.3.1.25}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.26}简述数组与指针的区别？}{16}{subsubsection.3.1.26}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.27}类成员函数的重载、覆盖和隐藏区别？}{16}{subsubsection.3.1.27}}
\@writefile{toc}{\contentsline {subparagraph}{成员函数被重载的特征}{16}{section*.20}}
\@writefile{toc}{\contentsline {subparagraph}{覆盖是指派生类函数覆盖基类函数，特征是}{16}{section*.21}}
\@writefile{toc}{\contentsline {subparagraph}{“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下}{17}{section*.22}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.28}如何打印出当前源文件的文件名以及源文件的当前行号？}{17}{subsubsection.3.1.28}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.29}关于\_\_stdcall和\_\_cdecl调用方式的理解}{17}{subsubsection.3.1.29}}
\@writefile{toc}{\contentsline {subparagraph}{案例理解}{17}{section*.23}}
\@writefile{toc}{\contentsline {subparagraph}{清理区别}{17}{section*.24}}
\@writefile{toc}{\contentsline {subparagraph}{参数区别}{18}{section*.25}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.30}腾讯-输出是什么 }{18}{subsubsection.3.1.30}}
\@writefile{toc}{\contentsline {section}{\numberline {4}STL 组件与使用}{19}{section.4}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.1}题目}{19}{subsection.4.1}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {4.1.1}使用过哪些组件？}{19}{subsubsection.4.1.1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.2}体会}{19}{subsection.4.2}}
\@writefile{toc}{\contentsline {section}{\numberline {5}Boost 组件与使用}{20}{section.5}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.1}题目}{20}{subsection.5.1}}
\@writefile{toc}{\contentsline {subparagraph}{boost 的网络库ASIO}{20}{section*.26}}
\@writefile{toc}{\contentsline {section}{\numberline {6}网络、服务器编程}{21}{section.6}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.1}参考C++\_NetProgram}{21}{subsection.6.1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.2}题目}{21}{subsection.6.2}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.1}多线程和多进程的区别}{21}{subsubsection.6.2.1}}
\@writefile{toc}{\contentsline {subparagraph}{线程所私有的}{21}{section*.27}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.2}多线程锁的种类有哪些？}{21}{subsubsection.6.2.2}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.3}自旋锁和互斥锁的区别？}{21}{subsubsection.6.2.3}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.4}进程间通信和线程间通信}{21}{subsubsection.6.2.4}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.5}多线程程序架构，线程数量应该如何设置？}{21}{subsubsection.6.2.5}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.6}什么是原子操作，gcc提供的原子操作原语，使用这些原语如何实现读写锁？}{21}{subsubsection.6.2.6}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.7}网络编程设计模式，reactor/proactor/半同步半异步模式？}{21}{subsubsection.6.2.7}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.8}有一个计数器，多个线程都需要更新，会遇到什么问题，原因是什么，应该如何做？如何优化？}{22}{subsubsection.6.2.8}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.9}如果select返回可读，结果只读到0字节，什么情况？}{22}{subsubsection.6.2.9}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.10}connect可能会长时间阻塞，怎么解决?}{22}{subsubsection.6.2.10}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.11}keepalive 是什么东西？如何使用？}{22}{subsubsection.6.2.11}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.12}socket什么情况下可读？}{22}{subsubsection.6.2.12}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.13}udp调用connect有什么作用？}{22}{subsubsection.6.2.13}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.14}socket编程，如果client断电了，服务器如何快速知道？}{22}{subsubsection.6.2.14}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.15}怎么清理僵尸进程}{22}{subsubsection.6.2.15}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.16}系统调用函数}{22}{subsubsection.6.2.16}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.17}socket 的阻塞和非阻塞的概念}{22}{subsubsection.6.2.17}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.18}信号与信号量之间的区别}{22}{subsubsection.6.2.18}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.19}TCP头大小，包含字段？三次握手，四次断开描述过程，都有些什么状态。状态变迁图。TCP/IP收发缓冲区}{22}{subsubsection.6.2.19}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.20}使用udp和tcp进程网络传输，为什么tcp能保证包是发送顺序，而 udp无法保证？}{22}{subsubsection.6.2.20}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.21}epoll哪些触发模式，有啥区别？}{22}{subsubsection.6.2.21}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.22}tcp与udp的区别（必问）为什么TCP要叫做数据流？}{22}{subsubsection.6.2.22}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.23}流量控制和拥塞控制的实现机制}{22}{subsubsection.6.2.23}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.24}滑动窗口的实现机制}{22}{subsubsection.6.2.24}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.25}epoll和select的区别？}{23}{subsubsection.6.2.25}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.26}网络中，如果客户端突然掉线或者重启，服务器端怎么样才能立刻知道？}{23}{subsubsection.6.2.26}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.27}TTL是什么？有什么用处，通常那些工具会用到它？ping? traceroute? ifconfig? netstat?}{23}{subsubsection.6.2.27}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.28}linux的五种IO模式/异步模式.}{23}{subsubsection.6.2.28}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.29}请说出http协议的优缺点.}{23}{subsubsection.6.2.29}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.30}NAT类型，UDP穿透原理}{23}{subsubsection.6.2.30}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.31}大规模连接上来，并发模型怎么设计}{23}{subsubsection.6.2.31}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.32}流量控制与拥塞控制的区别，节点计算机怎样感知网络拥塞了？}{23}{subsubsection.6.2.32}}
\@writefile{toc}{\contentsline {section}{\numberline {7}多线程编程}{24}{section.7}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.1}参考C++\_Advanced}{24}{subsection.7.1}}
\@writefile{toc}{\contentsline {section}{\numberline {8}算法}{25}{section.8}}
\@writefile{toc}{\contentsline {subsection}{\numberline {8.1}数据结构}{25}{subsection.8.1}}
\@writefile{toc}{\contentsline {section}{\numberline {9}程序设计}{26}{section.9}}
\@writefile{toc}{\contentsline {subsection}{\numberline {9.1}设计模式}{26}{subsection.9.1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {9.2}UML}{26}{subsection.9.2}}
\@writefile{toc}{\contentsline {section}{\numberline {10}OpenGL}{27}{section.10}}
\@writefile{toc}{\contentsline {subsection}{\numberline {10.1}参考OpenGL}{27}{subsection.10.1}}
\@writefile{toc}{\contentsline {section}{\numberline {11}DirectX}{28}{section.11}}
\@writefile{toc}{\contentsline {subsection}{\numberline {11.1}参考DirectX9}{28}{subsection.11.1}}
\@writefile{toc}{\contentsline {section}{\numberline {12}PC游戏试玩记录}{29}{section.12}}
\@writefile{toc}{\contentsline {subsection}{\numberline {12.1}坦克世界}{29}{subsection.12.1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {12.2}生死狙击}{29}{subsection.12.2}}
\@writefile{toc}{\contentsline {paragraph}{连跳}{29}{section*.28}}
\@writefile{toc}{\contentsline {paragraph}{升级跳}{29}{section*.29}}
\@writefile{toc}{\contentsline {subsection}{\numberline {12.3}Dota2}{29}{subsection.12.3}}
\@writefile{toc}{\contentsline {paragraph}{1.起步-新手}{29}{section*.30}}
\@writefile{toc}{\contentsline {paragraph}{2.准备-新玩}{29}{section*.31}}
\@writefile{toc}{\contentsline {subsection}{\numberline {12.4}CrossFire}{29}{subsection.12.4}}
\@writefile{toc}{\contentsline {subsection}{\numberline {12.5}League Of Legends}{29}{subsection.12.5}}
\@writefile{toc}{\contentsline {subsection}{\numberline {12.6}文明5}{29}{subsection.12.6}}
\@writefile{toc}{\contentsline {subsection}{\numberline {12.7}极品飞车-系列}{29}{subsection.12.7}}
\@writefile{toc}{\contentsline {subsection}{\numberline {12.8}QQ飞车--鹏鹏卡丁车}{29}{subsection.12.8}}
